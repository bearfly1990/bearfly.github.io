---
layout: post
title: Work Diary (01)
subtitle: Summarize the test case I met yesterday
date: 2018-11-21
author: BF
header-img: img/bf/wall_01.jpg
catalog: true
tags:
  - test
  - private
---

# 背景

昨天有一个重要的测试任务，感觉可以做的更好，有一些点可以稍微总结分析一下，作为参考。

# 主要任务

由于客户遇到了相对严重的问题（在极端情况下，客户及本地无法重现），这次需要修复（根据分析 Log 与代码，得到修复方案），并根据客户需求增加了 log 的输出。

可测版本在昨天中午准备就绪，大约 1 点钟左右开始正式测试。

主要测试点为：

- 冒烟及回归测试，保证新的版本没有影响原来的功能。（包括将一些参数设长，如 timeout 的时间，保证没有意外错误）
- 通过特殊代码，主动触发 bug，检测能否 catch 到，保证客户方面再出现这方面的情况，不会再出来重大错误。
- 通过设置特殊参数，使系统容易触发异常，并测试在参数正常情况下，重置服务后能否修复并继续执行任务。
- etc...
- **测试新增的 Log 功能**
- **测试新的改动尤其是 Log 功能对性能的影响**

# 测试过程回顾与分析

首先第一点，自己没做好的是没有制定详细的测试计划。 虽然在小本本上有简单罗列测试要点，但没有完整的 Test Cases 列表，导致后续测试工作“无法可依”，尤其是在遇到问题的情况下，容易思路混淆。

至少提前一天已经知道大概的测试内容，但还是小看了相关测试的复杂度与可能遇到的问题。

**至下午 5 点**左右，除 Log 相关功能外，其它测试点基本完成。

## 出不来的 Log

当时把 Log 功能放到最后，是因为与开发人员沟通过，觉得功能实现简单，相对容易测试，所以认为优先级最低（结果证明出问题的就是这边，尴尬）。

开始测试 Log 功能之后，便一直发现不能得到预期的结果，开始怀疑功能有问题，开始与开发人员一同查看。

这边就涉及到一个问题，就是开发人员一直认为是配置与运行使用的问题，所以一直在尝试重启，配置，运行的过程，所以耗费了不少时间。

主要是我本身对这个功能模块不是很熟悉，所以只能不断根据开发人员的建议配置与重试，但仍然无法成功，此时已将近 **7 点**左右。

> 这次的增加的 Log 功能是基于原先已有的模块，增加了输出的内容，原计划是在 Debug 级别配置。

最后，向原先熟悉相关模块的开发人员寻求帮忙与确认后，找到了问题的症结，Debug 级别只有在 Debug 版本能会输出想到的内容，在 Release 版本是不会输出的，这属于 C++的坑。

## 消失的进程

在明确问题后，开发人员改过代码，special build 了一个版本给我测试，能够看到预期的 Log 内容, 本来还是很开心的。

但是当这个问题解决后，我们的目光又聚集到另外一个问题: xxxService 的进程数目不对，并一直在创建与销毁。

> 在我们在系统中，需要配置 xxxService 的数量，当服务整个起来之后，可以在 task manager 那边看到相应数目的进程。
> 这些进程会提供一定的服务，并且上文提到的 Log 便是它们来输出的。

当时的现象是：

- Log 能够输出，但是文件数量一直在增加(正常情况是文件数量应与进程数一致，并在短期内不会有新建与销毁)
- 在任务管理器可以看出，设置了 15 个数，但实际上只有 3 个，并且偶尔能看到新增几个新的，但立马消失。
- 不管 Log 打开还是关闭，都有同样的问题。
- 在其它相关联的服务 log 中，有大量的与 xxxService Time Out 的 error（侧面证明了一直在销毁与新建）
- 不影响正常的业务处理
- etc...

其实在下午的测试过程中，就有感觉一些不对劲，但当时关注点不在这上面，而且一直是在做破坏性测试，所以一直有一些 error 都没太在意。
尤其是这个问题不影响正常的业务处理。

当所有功能没有问题之后，目光就集中在这上边，开始意识到问题的严重性，带着这样的问题，产品肯定是不能发布的。

所以一方面，开发人员在查找原因，而我开始对比测试。

## 原因到底是什么

开发人员的反馈是最新加的功能不会有大的问题，逻辑很简单，而最近两天基本上只有这次的改动。很可能是别的问题，所以一直在查找。

而我这边，首先确认了下上一个 release 版本是没有这样的问题的，然后也尝试把 log disable 掉，没有输出，但在新版本还是有这样的问题。
潜意识里觉得新加的 Log 功能应该是没有问题了，这时，又没有了头绪，而时间已经将近 10 点。

最后，开发人员有了另一种假设，可能是编译的问题，导致 exe 自己出错死掉（但其实不能解释为什么还坚挺地活着几个）。
并且发现当前版本前一天的 build 是可以的，便更加相信是其它因素。

我第一次听说可能会有这样的问题（build 不对），基本上那时便没有更深入的去定位出问题的范围。

等到近事出反常必有妖，新的 full build 版本出来后，我尝试了下，还是不行，便陷入的僵局。

## 柳暗花明

由于时间太晚，便只能暂时做罢（哈哈哈哈哈，要是某些公司，肯定等不及第二天再来看的）

但事出反常必有妖，我一直觉得肯定是代码哪里有问题，但我心里也把 Log 这边排除了（毕竟逻辑相对简单，只是多增加输出，更有两位开发人员的肯定）。
更觉得是其它的问题。

早上来了之后，便与 David 一起 review，我把现象展示出来，在 David 的提示下，我们将 error log 打开（不确定昨晚是否一样打开过）。
重现问题之后，猛然在几个进程的 log 里看到了一段 exception,大意是 map 的 key 不对，找不到。

这回我看到了代码，确实在新的更改那边有取 map 值的操作，但理论上来说，从 map 中取值最多为空 null 之类，不应该有重大 error.

在简单分析之后，还是重新修改编译了一个版本，我尝试之后，问题果然解决了。

根源是在为了取一个值(user)的时候，用的是已有的一个公共方法（方式)，而在当前使用情况下，会诱发问题，更详细具体的根源我没有深究。

# 反思

总之，如果做的更好一点，就能更早的定位问题，让代价更小一些。

- 要制定相对详细的测试计划，辅助整个流程的进行。
- 优先测试目标明确的case，比如这次的log，如果一开始就发现出不来，就可以给回开发人员研究，自己做其它的测试，更高效一些。
- 一定要按自己的思路去定位问题，在有限的条件下，缩小问题的范围，确定好的与有问题的版本的界线。
- **不要相信开发人员**，哈哈哈哈哈，revert 大法好，在实现不能确定问题根源情况下，回退代码测试是最有效的。尤其是像这次代码 commit 很少的情况下，代价相对很低。

晚安
